package game;

import java.util.*;
import java.awt.event.KeyEvent;
import java.io.*;

/**
 * This is the model for the game. It represents the entire state of the game at
 * the present moment. In this version, the player is presented with two kinds
 * of fish (good and bad) that come from sides (left or right) and have certain
 * visual and auditory cues. The player tries to identify the fish by pressing the appropriate key.
 * 
 * Keypresses are handled in the GameView class which creates this GameModel The
 * system logs each keypress storing info about the press and the reaction time.
 * If no fish was present it was a miscue and we store the "reaction time" as
 * the time since the last fish appeared The fish are generated by
 * reading data from a file created by the ScriptGenerator class.
 * 
 * 
 */
public class GameModel {
	
	/**
	 * Create a new GameModel based on the GameSpec parameter
	 * @param gameSpec
	 */
	public GameModel(GameSpec gameSpec){
		this.gameSpec = gameSpec;
		this.gameOver=false;
	}


	/**
	 * The gameSpec is a set of property/value pairs that describes everything
	 * about the current game aesthetics and mechanics except for the actual
	 * sequence of fish that should be generated.  So the background image and sound,
	 * the sound files for the good and bad fish, etc.
	 */
	public GameSpec gameSpec;


    /**
     * the SIZE of the GameBoard is 100x100 in model units
     * when it is drawn to a screen it is stretched in the x and y directions
     * to fit the screen
     */
	public static final double SIZE=100;
	private double width=SIZE;
	private double height=SIZE;

	
	
	
	/*
	 * methods related to the current Fish
	 */
	private Fish currentFish = null;

	public Fish getCurrentFish(){
		return this.currentFish;
	}
	/**
	 * get the number of fish on the board (currently either 0 or 1)
	 * @return number of fish on screen
	 */
	public int getNumFish() {
		return (currentFish==null?0:1);
	}

	/**
	 * remove the lastFish from the stream turn off its clip and make it
	 * inactive
	 * 
	 * @return
	 */
	public void removeLastFish() {
		currentFish.ct.stop();
		currentFish=null;
	}
	


	/*
	 * methods related to the gameOver field
	 * which is true when the game is over
	 */
	
	// this is set to true when the session is over ...
	// we need to add a timer to end the session, or have the
	// experimenter end the session ...
	private boolean gameOver = false;
	
	/**
	 *  this checks if the game is over.
	 * @return true if the game is over
	 */
	public boolean isGameOver() {
		return gameOver;
	}

	/**
	 * sets gameOver to true or false
	 * @param gameOver
	 */
	public void setGameOver(boolean gameOver) {
		this.gameOver = gameOver;
	}
	
	
	/*
	 * methods related to the paused field
	 */
	
	// pause the game, in case the subject needs to go to the bathroom!
	private boolean paused = true;

	/**
	 * returns true if the game is paused
	 * @return the paused
	 */
	public boolean isPaused() {
		return paused;
	}

	/*
	 * pauses or resumes the game
	 * @param paused
	 *            the paused to set
	 */
	private void setPaused(boolean paused) {
		this.paused = paused;
	}
	
	
	


	private long nextFishTime = 0;

	/*
	 * this variable holds the information about the next fish to be released!
	 */
	private Fish nextFish = new Fish();
	
	
	private long gameStart = System.nanoTime();
	

	// this is true if we are reading from a script
	private String inputScriptFileName;

	/**
	 * sets the input script to the specified filename
	 * @param fileName
	 */
	public void setInputScript(String fileName) {
		this.inputScriptFileName = fileName;
	}
	
	

	// this is a scanner used to read the fish creation info
	private Scanner scan; // = new Scanner(typescript);


	
	
	// this is where the log will be written...
	public BufferedWriter logfile;

	




	
	

	private void getLogFile() {
		if (this.logfile == null) {
			// open the logfile
			long now = System.currentTimeMillis();
			String logname = "logs/log" + now + ".txt";
			try {
				this.logfile = new BufferedWriter(new FileWriter(new File(
						logname)));
			} catch (IOException e) {
				System.out.println("Problems opening logfile:" + logname + ": "
						+ e);
				e.printStackTrace();
			}
		}
	}


	/**
	 * this reads the next line in the Script file property/value lines cause
	 * the system to update the GameSpec fish launches read the interval and use
	 * it to compute nextFishTime and read the species and side and store it in
	 * this.nextFish
	 * 
	 * We should read this right after launching a fish, so we can know when its
	 * time to launch the next fish!
	 * 
	 * @return
	 */

	public void updateNextFishTime(long now) {

		// initialize the scanner if its the first time we're reading a line
		if (scan == null) createScanner();	
		if (scan == null) return;
		
		
		// this should never happen!
		if (!scan.hasNext()) {
			System.out.println("This should never happen!  Reached end of file!!");
			this.setGameOver(true);
			this.nextFishTime =  this.nextFishTime + 10 * 1000000000L;
			return;
		}
		
		
		long interval = scan.nextLong();

		// process all the 0 interval commands (which set game properties)

		while (interval == -1) {
			interval = updateGameSpec();
		}

		// calculate the next FishTime and the basic characteristics of the
		// nextFish (species and side)
		if (interval==0){
			setGameOver(true);
			return;
		}
		readNextFishData(now, interval);

	}
	
	
	
	
	private void readNextFishData(long now, long interval) {
		nextFishTime = interval *1000000 + now;
		// the sound file and visual hertz in the input files are not used and are just documentation....
		String sound = scan.next();
		int visualhz = scan.nextInt();
		int congruent = scan.nextInt();
		int trialnum = scan.nextInt();
		String fromLeft = scan.next();

		String species = scan.next();

		scan.nextLine(); // skip over the rest of the line

		// create the next Fish to be launched
		nextFish.avmode = gameSpec.avmode;
		nextFish.fromLeft = fromLeft.equals("left");
		nextFish.setCongruent(congruent);
		nextFish.setTrial(trialnum);
		nextFish.species = (species.equals("good")) ? Species.good : Species.bad;
	}
	
	
	private long updateGameSpec() {
		long interval;
		String prop = scan.next();
		String value = scan.next();
		scan.nextLine(); // skip over the rest of the line
		writeToLog("0\t" + prop + "\t" + value);
		if (prop.equals("gameover")) {
			this.stop();
			this.setGameOver(true);
			this.nextFishTime = System.nanoTime() + 10*1000000000L;
			return 0;
		}
		// System.out.println("interval="+interval+" prop="+prop+" value="+value);
		interval = scan.nextLong();

		gameSpec.update(prop, value);
		return interval;
	}
	
	
	private void createScanner() {
		try {
			scan = new Scanner(new File(this.inputScriptFileName));
		} catch (FileNotFoundException e) {
			System.out.println("Error in reading inputScriptFile:"
					+ this.inputScriptFileName + " " + e);
			e.printStackTrace();
			this.stop();
		}
	}

	private long lastLogEventTimeNano = 0;


	public void pause() {

		this.nextFishTime = Long.MAX_VALUE;
		setPaused(true);
		this.writeToLog("PAUSE");
	}

	public void restart() {

		this.nextFishTime = System.nanoTime() + 2 * 1000000000L;
		setPaused(false);
		this.writeToLog("RESTART");
	}

	// spawn an actor randomly
	/**
	 * randomly spawns a new fish,based on the script and resets the time for
	 * the next fish to be spawned...
	 * A new fish is spawned D milliseconds after the current fish disappears.
	 * This means that the nextFishTime variable has to be updated when a key 
	 * is pressed! The properties of the fish (excluding when it should appear)
	 * are read from a file and stored in the "nextFish" variable.
	 */
	public void spawnFish() {
		if (this.isGameOver())
			return;
		
		Side side = (this.nextFish.fromLeft) ? Side.left : Side.right;
		Species s = this.nextFish.species;
		// System.out.println("spawning "+s+" "+side);

		// pick starting location and velocity
		double y = this.height / 2;

		double x = (side == Side.left) ? 1 : this.width - 1;

		// then make an actor with that position
		Fish a = new Fish(x, y, true, s, gameSpec.stereo,
				gameSpec.good.soundFile, gameSpec.bad.soundFile,gameSpec.avmode,nextFish.congruent);
		
		
		// and fill in all the needed fields...
		// we don't need both fromLeft and origin .... eliminate fromLeft...
		a.fromLeft = (side == Side.left);
		a.origin = (side == Side.left) ? 0 : 1; // we'll convert origin to Side
												// later

		a.setCongruent(nextFish.congruent);
		a.setTrial(nextFish.trial);
		// make sure it is moving inward if it comes from the right
		if (!a.fromLeft)
			a.vy = -a.vy;
		// a.radius=4;
		// start playing the music for the fish
		if (a.fromLeft)
			a.ct = a.ctL;
		else
			a.ct = a.ctR;
		//if fish is not silent play sound
		if (a.congruent != 2 && gameSpec.avmode != 1) {
			a.ct.loop();
			soundflash=true;
			soundIndicatorUpdate=System.nanoTime()+50000000l;
		} else if (gameSpec.avmode == 1){
			a.ct.loop();
			soundflash=true;
			soundIndicatorUpdate=System.nanoTime()+50000000l;
		}
		a.vx = (side == Side.left) ? 1 : -1;

		// add the fish to the list of actors...
		currentFish = a;

		//send a flash to the indicator
		flash=true;
		indicatorUpdate=System.nanoTime()+50000000l;
		writeToLog(a); // indicate that a was spawned
	}

	public void start() {
		this.paused=false;
		this.gameOver=false;
		this.nextFishTime = System.nanoTime();
		this.gameStart = nextFishTime;
		Fish.GAME_START = this.gameStart;
		updateNextFishTime(this.gameStart);

	}

	public void stop() {
		this.paused=true;
		this.gameOver=true;
		this.scan=null;
		this.setPaused(true);
		this.setGameOver(true);
		if (currentFish!=null){
			currentFish.ct.stop();
		}
		currentFish = null;

		try {
			if (logfile != null)
				logfile.close();
			logfile = null;
			System.out.println("closing log/script files");
		} catch (Exception e) {
			System.out.println("Problem closing logfile");
		}

	}

	/**
	 * if an actor moves off the board, in the x (or y) direction, it is bounced
	 * back into the board and its velocity in the offending direction is
	 * reversed
	 * 
	 * @param a
	 */
	public void keepOnBoard(Fish a) {
		if (a.x < 0) {
			a.x = -a.x;
			a.vx = -a.vx;
		} else if (a.x > width) {
			a.x = width - (a.x - width);
			a.vx = -a.vx;
		}
		if (a.y < 0) {
			a.y = -a.y;
			a.vy = -a.vy;
		} else if (a.y > height) {
			a.y = height - (a.y - height);
			a.vy = -a.vy;
		}
	}

	
	
	/**
	 * This method is called from GameView when a clip needs to be handled 
	 * @param e
	 * @param goodclip
	 * @param badclip
	 */
	public synchronized boolean handleKeyPress(KeyEvent e) {
		// ALL OF THIS CODE SHOULD GO INTO A SYNCHRONIZED METHOD IN GameModel ...
		// now we will create the GameEvent for killing the last fish
		// first we need to get the current fish to see if the response was correct ...
		Fish lastFish = this.getCurrentFish();

		GameEvent ge = new GameEvent(e.getKeyChar(), lastFish);
		
		// then we update the NextFishTime which means reading in another line and 
		// storing the info about that fish in gm.nextFish
		
		// THIS MODIFIES gm and needs to be synchronized
		this.updateNextFishTime(ge.when);

		// get the response time and write it to the log
		long keyPressTime = ge.when;
		long responseTime = keyPressTime - lastFish.birthTime;

		String log = e.getKeyChar() + " " + responseTime / 1000000.0
				+ " " + ge.correctResponse + " " + lastFish;

		System.out.println(log);

		// THIS NEEDS TO BE SYNCHRONIZED
		this.writeToLog(ge);

		// play the appropriate sound and modify the score

		if (ge.correctResponse) {
			soundflash=true;
			soundIndicatorUpdate=System.nanoTime()+50000000l;
			this.wealth++;
			this.hits += 1;
		} else {
			soundflash=true;
			soundIndicatorUpdate=System.nanoTime()+50000000l;
			this.wealth--;
			this.misses += 1;
		}
		
		// Finally, remove the last fish (should only be one!)
		// but don't remove until the end as update could be called as we are pressing the key!!!
		// THIS NEEDS TO BE SYNCHRONIZED
		this.removeLastFish();
		return ge.correctResponse;
	}
	

	/**
	 * update moves all actors one step update will check if the difference
	 * between the lastUpdate and the current time is greater than the sRate
	 * plus a random number from 1 to 4, and spawn a fish if so.
	 */
	public synchronized void update() { 
		long now = System.nanoTime(); 
		
		if (isPaused() || isGameOver())
			return;


		// these are for the GUI
		totalActorTime = (currentActorTime) / 1000000;
		timeRemaining = 100 - (totalActorTime / timePerTrial);

		
		if ((now > this.nextFishTime) && currentFish==null) { // this means we need to launch a fish!!
			currentActorTime = 0;		
			spawnFish();
		}
		
		/*
		 *  Finally, we update  the fish 
		 */

		try {
			if (currentFish!= null) {
				Fish a = currentFish;
				a.update();
				keepOnBoard(a);

				if (!a.active) { // this is where we remove the fish if the user didn't press a key and the lifespan has been reached...
					a.ct.stop();
					previousActorTime += a.lifeSpan;
					currentActorTime = 0;
					this.noKeyPress += 1;
					GameEvent missedFishEvent = new GameEvent(a);
					updateNextFishTime(missedFishEvent.when);
					this.writeToLog(missedFishEvent);
					currentFish=null;
				} else {
					this.currentActorTime = a.lifeSpan;
				}

			}
		} catch (Exception e) {
			System.out.println("Exception on update: " + e);
		}

	}

	public int interpolateSize(double min, double max, long birth, long now,
			double freq) {
		double t = ((now - birth) / 1000000000.0) * freq;
		double y = 1 - 0.5 * (Math.sin(Math.PI * 2 * t) + 1);
		double s = min * y + max * (1 - y);
		int size = (int) Math.round(s);
		return size;
	}

	public int getVisualHZ(FishSpec fs) {
		return fs.throbRate;
	}
	
	
	
	
	/*****************************************************************************
	 * Fields used for the Graphical User Interface
	 * but that don't affect the model
	 */
	
	/**
	 * The variables below are all used in the GUI and don't affect how the model evolves in time.
	 */
	// time per trial is represented as tenths of seconds
	public double timePerTrial = 20;
	// time remaining is represented as a percentage
	public double timeRemaining = 100;
	// total actor time is the
	public double totalActorTime = 0;
	public double currentActorTime = 0;
	public double previousActorTime = 0;

	public int health = 10;
	public int wealth = 0;

	
	public boolean flash;

	public long indicatorUpdate;

	public boolean soundflash;
	
	public long soundIndicatorUpdate;
	

	/** these variables record good/bad hits */
	private int hits, misses, noKeyPress;

	/**
	 * returns the number of hits so far
	 * @return the hits
	 */
	public int getHits() {
		return hits;
	}


	/**
	 * @return the misses
	 */
	public int getMisses() {
		return misses;
	}


	/**
	 * @return the noKeyPress
	 */
	public int getNoKeyPress() {
		return noKeyPress;
	}


	
	/*****************************************************************************
	 * logging data
	 */
	

	public void writeToLog(Fish f) {

		String logLine = "launch\t" + f.species + "\t" + f.congruent
				+ "\t" + f.trial + "\t" + (f.fromLeft?"left":"right");

		writeToLog(logLine);
	}

	/**
	 * This writes a string to the log file and prefixes it with the number of
	 * milliseconds since the beginning of the session.
	 * 
	 * @param s
	 *            the string to be written to the log file
	 */
	public void writeToLog(String s) {
		try {
			long theTime = (System.nanoTime() - this.gameStart);

			long theInterval = theTime - lastLogEventTimeNano;
			lastLogEventTimeNano = theTime;

			int theSeconds = (int) Math.round(theInterval / 1000000.0);
			String logLine = theSeconds + GameEvent.sep + theTime / 1000000
					+ " " + s + "\n";
			getLogFile(); // make sure the logfile is open!
			this.logfile.write(logLine);
			this.logfile.flush();
			System.out.println("log:" + logLine);
		} catch (Exception e) {
			System.out.println("Error writing to log " + e);
		}
	}

	public void writeToLog(GameEvent e) {
		writeToLog(e.toString());
	}


}
